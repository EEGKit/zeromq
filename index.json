{
  "api/Bonsai.ZeroMQ.ConvertToFrame.html": {
    "href": "api/Bonsai.ZeroMQ.ConvertToFrame.html",
    "title": "Class ConvertToFrame",
    "keywords": "Class ConvertToFrame Represents an operator that converts a sequence of data objects into a sequence of message frames. Inheritance Object Combinator < Byte [], NetMQ.NetMQFrame > ConvertToFrame Inherited Members Combinator<Byte[], NetMQFrame>.Process(IObservable<Byte[]>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class ConvertToFrame : Combinator<byte[], NetMQFrame> Methods | Improve this Doc View Source Process(IObservable<Byte[]>) Converts a sequence of data buffers into an observable sequence of message frames. Declaration public override IObservable<NetMQFrame> Process(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source A sequence of byte-array objects representing the individual data buffers. Returns Type Description IObservable < NetMQ.NetMQFrame > A sequence of NetMQ.NetMQFrame objects representing individual message frames. Overrides Bonsai.Combinator<System.Byte[], NetMQ.NetMQFrame>.Process(System.IObservable<System.Byte[]>) | Improve this Doc View Source Process(IObservable<String>) Converts a sequence of string objects into an observable sequence of message frames. Declaration public IObservable<NetMQFrame> Process(IObservable<string> source) Parameters Type Name Description IObservable < String > source A sequence of String objects representing individual messages. Returns Type Description IObservable < NetMQ.NetMQFrame > A sequence of NetMQ.NetMQFrame objects encoding individual messages."
  },
  "api/Bonsai.ZeroMQ.ConvertToString.html": {
    "href": "api/Bonsai.ZeroMQ.ConvertToString.html",
    "title": "Class ConvertToString",
    "keywords": "Class ConvertToString Represents an operator that converts a sequence of message frames into a sequence of strings using the default encoding. Inheritance Object Combinator < NetMQ.NetMQFrame , String > Transform < NetMQ.NetMQFrame , String > ConvertToString Inherited Members Combinator<NetMQFrame, String>.Process(IObservable<NetMQFrame>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class ConvertToString : Transform<NetMQFrame, string> Methods | Improve this Doc View Source Process(IObservable<NetMQFrame>) Converts an observable sequence of message frames into a sequence of strings using the default encoding. Declaration public override IObservable<string> Process(IObservable<NetMQFrame> source) Parameters Type Name Description IObservable < NetMQ.NetMQFrame > source A sequence of NetMQ.NetMQFrame objects representing individual message frames. Returns Type Description IObservable < String > A sequence of strings extracted from each frame data buffer using the default encoding. Overrides Bonsai.Combinator<NetMQ.NetMQFrame, System.String>.Process(System.IObservable<NetMQ.NetMQFrame>)"
  },
  "api/Bonsai.ZeroMQ.Dealer.html": {
    "href": "api/Bonsai.ZeroMQ.Dealer.html",
    "title": "Class Dealer",
    "keywords": "Class Dealer Represents an operator that creates a dealer socket for transmitting a sequence of messages and receiving responses asynchronously while maintaining load balance. Inheritance Object Combinator < NetMQ.NetMQMessage , NetMQ.NetMQMessage > Dealer Inherited Members Combinator<NetMQMessage, NetMQMessage>.Process(IObservable<NetMQMessage>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Dealer : Combinator<NetMQMessage, NetMQMessage> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Process(IObservable<NetMQMessage>) Creates a dealer socket for transmitting an observable sequence of request messages and receiving responses asynchronously while maintaining load balance. Declaration public override IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source The sequence of multiple part request messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the dealer socket. Overrides Bonsai.Combinator<NetMQ.NetMQMessage, NetMQ.NetMQMessage>.Process(System.IObservable<NetMQ.NetMQMessage>) | Improve this Doc View Source Process(IObservable<Byte[]>) Creates a dealer socket for transmitting an observable sequence of binary-coded requests and receiving responses asynchronously while maintaining load balance. Declaration public IObservable<NetMQMessage> Process(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source The sequence of binary-coded request messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the dealer socket. | Improve this Doc View Source Process(IObservable<String>) Creates a dealer socket for transmitting an observable sequence of String requests and receiving responses asynchronously while maintaining load balance. Declaration public IObservable<NetMQMessage> Process(IObservable<string> source) Parameters Type Name Description IObservable < String > source The sequence of String request messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the dealer socket."
  },
  "api/Bonsai.ZeroMQ.GetIdentity.html": {
    "href": "api/Bonsai.ZeroMQ.GetIdentity.html",
    "title": "Class GetIdentity",
    "keywords": "Class GetIdentity Represents an operator that extracts all the identity frames from each multiple part message in the sequence, up to and including the empty delimiter frame. Inheritance Object Combinator < NetMQ.NetMQMessage , NetMQ.NetMQFrame > GetIdentity Inherited Members Combinator<NetMQMessage, NetMQFrame>.Process(IObservable<NetMQMessage>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class GetIdentity : Combinator<NetMQMessage, NetMQFrame> Methods | Improve this Doc View Source Process(IObservable<NetMQMessage>) Extracts all the identity frames from each multiple part message in an observable sequence, up to and including the empty delimiter frame. Declaration public override IObservable<NetMQFrame> Process(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source An observable sequence of NetMQ.NetMQMessage objects representing the multiple part messages from which to extract the identity frames. Returns Type Description IObservable < NetMQ.NetMQFrame > A sequence of NetMQ.NetMQFrame objects representing all the identity frames in each message of the source sequence. Overrides Bonsai.Combinator<NetMQ.NetMQMessage, NetMQ.NetMQFrame>.Process(System.IObservable<NetMQ.NetMQMessage>)"
  },
  "api/Bonsai.ZeroMQ.html": {
    "href": "api/Bonsai.ZeroMQ.html",
    "title": "Namespace Bonsai.ZeroMQ",
    "keywords": "Namespace Bonsai.ZeroMQ Classes ConvertToFrame Represents an operator that converts a sequence of data objects into a sequence of message frames. ConvertToString Represents an operator that converts a sequence of message frames into a sequence of strings using the default encoding. Dealer Represents an operator that creates a dealer socket for transmitting a sequence of messages and receiving responses asynchronously while maintaining load balance. GetIdentity Represents an operator that extracts all the identity frames from each multiple part message in the sequence, up to and including the empty delimiter frame. ProxyBackend Represents an operator that creates and starts a proxy with the specified back-end socket. ProxyFrontend Represents an operator that specifies the front-end socket for a proxy. Publisher Represents an operator that creates a publisher socket for transmitting a sequence of messages as part of the pub-sub pattern. Pull Represents an operator that creates a pull socket for receiving a sequence of messages as part of the push-pull pattern. Push Represents an operator that creates a push socket for transmitting a sequence of messages as part of the push-pull pattern. Request Represents an operator that creates a request socket for transmitting a sequence of request messages and receiving responses as part of the req-rep pattern. Response Represents an operator that creates a response socket for receiving a sequence of request messages and transmitting generated responses. ResponseContext Represents a request message received by a response socket. Router Represents an operator that creates a router socket for tracking the identity of received requests so that responses can be matched even if computed concurrently. SendResponse Represents an operator that computes the result of a remote request asynchronously and transmits the response through the corresponding socket. SocketInfo Represents information required for creating a NetMQ.NetMQSocket . Subscriber Represents an operator that creates a subscriber socket for receiving a sequence of messages as part of the pub-sub pattern. ToMessage Represents an operator that creates a multiple part message from an observable sequence. Enums SocketType Specifies the basic types of message-queue sockets implementing the core patterns (pub-sub, req-rep, dealer-router, etc)."
  },
  "api/Bonsai.ZeroMQ.ProxyBackend.html": {
    "href": "api/Bonsai.ZeroMQ.ProxyBackend.html",
    "title": "Class ProxyBackend",
    "keywords": "Class ProxyBackend Represents an operator that creates and starts a proxy with the specified back-end socket. Inheritance Object Combinator < SocketInfo , Unit > ProxyBackend Implements INamedElement Inherited Members Combinator<SocketInfo, Unit>.Process(IObservable<SocketInfo>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class ProxyBackend : Combinator<SocketInfo, Unit>, INamedElement Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String | Improve this Doc View Source SocketType Gets or sets a value specifying the type of socket to use as the back-end for a proxy. Declaration public SocketType SocketType { get; set; } Property Value Type Description SocketType Methods | Improve this Doc View Source Process(IObservable<SocketInfo>) Creates and starts a proxy with the specified back-end socket. Declaration public override IObservable<Unit> Process(IObservable<SocketInfo> source) Parameters Type Name Description IObservable < SocketInfo > source A sequence of SocketInfo objects representing information about the front-end socket to use for the proxy. A new proxy will be created and started for each value in the sequence. Returns Type Description IObservable < Unit > An observable sequence whose observers will never get called. The proxy is started purely for its side-effects of routing messages from the front-end to the back-end sockets. Overrides Bonsai.Combinator<Bonsai.ZeroMQ.SocketInfo, System.Reactive.Unit>.Process(System.IObservable<Bonsai.ZeroMQ.SocketInfo>) Explicit Interface Implementations | Improve this Doc View Source INamedElement.Name Declaration string INamedElement.Name { get; } Returns Type Description String Implements INamedElement"
  },
  "api/Bonsai.ZeroMQ.ProxyFrontend.html": {
    "href": "api/Bonsai.ZeroMQ.ProxyFrontend.html",
    "title": "Class ProxyFrontend",
    "keywords": "Class ProxyFrontend Represents an operator that specifies the front-end socket for a proxy. Inheritance Object Source < SocketInfo > ProxyFrontend Implements INamedElement Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class ProxyFrontend : Source<SocketInfo>, INamedElement Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Remarks All messages from this endpoint will be forwarded into the proxy back-end. | Improve this Doc View Source SocketType Gets or sets a value specifying the type of socket to use as the front-end for a proxy. Declaration public SocketType SocketType { get; set; } Property Value Type Description SocketType Methods | Improve this Doc View Source Generate() Specifies the front-end socket for a proxy. Declaration public override IObservable<SocketInfo> Generate() Returns Type Description IObservable < SocketInfo > An observable sequence containing a single SocketInfo object representing information required for creating the front-end socket for a proxy. Overrides Bonsai.Source<Bonsai.ZeroMQ.SocketInfo>.Generate() Explicit Interface Implementations | Improve this Doc View Source INamedElement.Name Declaration string INamedElement.Name { get; } Returns Type Description String Implements INamedElement"
  },
  "api/Bonsai.ZeroMQ.Publisher.html": {
    "href": "api/Bonsai.ZeroMQ.Publisher.html",
    "title": "Class Publisher",
    "keywords": "Class Publisher Represents an operator that creates a publisher socket for transmitting a sequence of messages as part of the pub-sub pattern. Inheritance Object Combinator < NetMQ.NetMQMessage , NetMQ.NetMQMessage > Sink < NetMQ.NetMQMessage > Publisher Inherited Members Combinator<NetMQMessage, NetMQMessage>.Process(IObservable<NetMQMessage>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Publisher : Sink<NetMQMessage> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String | Improve this Doc View Source Topic Gets or sets the topic under which to publish each sent message. Declaration public string Topic { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Process(IObservable<NetMQMessage>) Creates a publisher socket for transmitting an observable sequence of multiple part messages. Declaration public override IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source The sequence of multiple part messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the multiple part messages over a publisher socket. Overrides Bonsai.Combinator<NetMQ.NetMQMessage, NetMQ.NetMQMessage>.Process(System.IObservable<NetMQ.NetMQMessage>) | Improve this Doc View Source Process(IObservable<Byte[]>) Creates a publisher socket for transmitting an observable sequence of binary coded messages. Declaration public IObservable<byte[]> Process(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source The sequence of binary coded messages to transmit. Returns Type Description IObservable < Byte []> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the binary coded messages over a publisher socket. | Improve this Doc View Source Process(IObservable<String>) Creates a publisher socket for transmitting an observable sequence of String messages. Declaration public IObservable<string> Process(IObservable<string> source) Parameters Type Name Description IObservable < String > source The sequence of String messages to transmit. Returns Type Description IObservable < String > An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the String messages over a publisher socket. See Also Subscriber"
  },
  "api/Bonsai.ZeroMQ.Pull.html": {
    "href": "api/Bonsai.ZeroMQ.Pull.html",
    "title": "Class Pull",
    "keywords": "Class Pull Represents an operator that creates a pull socket for receiving a sequence of messages as part of the push-pull pattern. Inheritance Object Source < NetMQ.NetMQMessage > Pull Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Pull : Source<NetMQMessage> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Generate() Creates a pull socket for receiving an observable sequence of multiple part messages as part of the push-pull pattern. Declaration public override IObservable<NetMQMessage> Generate() Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing all multiple part messages received from the pull socket. Overrides Bonsai.Source<NetMQ.NetMQMessage>.Generate() See Also Push"
  },
  "api/Bonsai.ZeroMQ.Push.html": {
    "href": "api/Bonsai.ZeroMQ.Push.html",
    "title": "Class Push",
    "keywords": "Class Push Represents an operator that creates a push socket for transmitting a sequence of messages as part of the push-pull pattern. Inheritance Object Combinator < NetMQ.NetMQMessage , NetMQ.NetMQMessage > Sink < NetMQ.NetMQMessage > Push Inherited Members Combinator<NetMQMessage, NetMQMessage>.Process(IObservable<NetMQMessage>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Push : Sink<NetMQMessage> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Process(IObservable<NetMQMessage>) Creates a push socket for transmitting an observable sequence of multiple part messages. Declaration public override IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source The sequence of multiple part messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the multiple part messages over a push socket. Overrides Bonsai.Combinator<NetMQ.NetMQMessage, NetMQ.NetMQMessage>.Process(System.IObservable<NetMQ.NetMQMessage>) | Improve this Doc View Source Process(IObservable<Byte[]>) Creates a push socket for transmitting an observable sequence of binary coded messages. Declaration public IObservable<byte[]> Process(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source The sequence of binary coded messages to transmit. Returns Type Description IObservable < Byte []> An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the binary coded messages over a push socket. | Improve this Doc View Source Process(IObservable<String>) Creates a push socket for transmitting an observable sequence of String messages. Declaration public IObservable<string> Process(IObservable<string> source) Parameters Type Name Description IObservable < String > source The sequence of String messages to transmit. Returns Type Description IObservable < String > An observable sequence that is identical to the source sequence but where there is an additional side effect of transmitting the String messages over a push socket. See Also Pull"
  },
  "api/Bonsai.ZeroMQ.Request.html": {
    "href": "api/Bonsai.ZeroMQ.Request.html",
    "title": "Class Request",
    "keywords": "Class Request Represents an operator that creates a request socket for transmitting a sequence of request messages and receiving responses as part of the req-rep pattern. Inheritance Object Combinator < Byte [], NetMQ.NetMQMessage > Request Inherited Members Combinator<Byte[], NetMQMessage>.Process(IObservable<Byte[]>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Request : Combinator<byte[], NetMQMessage> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Process(IObservable<NetMQMessage>) Creates a request socket for transmitting an observable sequence of multiple part request messages and returns all received responses. Declaration public IObservable<NetMQMessage> Process(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source The sequence of multiple part request messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the request socket. | Improve this Doc View Source Process(IObservable<Byte[]>) Creates a request socket for transmitting an observable sequence of binary-coded request messages and returns all received responses. Declaration public override IObservable<NetMQMessage> Process(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source The sequence of binary-coded request messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the request socket. Overrides Bonsai.Combinator<System.Byte[], NetMQ.NetMQMessage>.Process(System.IObservable<System.Byte[]>) | Improve this Doc View Source Process(IObservable<String>) Creates a request socket for transmitting an observable sequence of String request messages and returns all received responses. Declaration public IObservable<NetMQMessage> Process(IObservable<string> source) Parameters Type Name Description IObservable < String > source The sequence of String request messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part responses received from the request socket."
  },
  "api/Bonsai.ZeroMQ.Response.html": {
    "href": "api/Bonsai.ZeroMQ.Response.html",
    "title": "Class Response",
    "keywords": "Class Response Represents an operator that creates a response socket for receiving a sequence of request messages and transmitting generated responses. Inheritance Object Source < ResponseContext > Response Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Response : Source<ResponseContext> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Generate() Creates a response socket for receiving an observable sequence of request messages and transmitting generated responses. Declaration public override IObservable<ResponseContext> Generate() Returns Type Description IObservable < ResponseContext > An observable sequence of ResponseContext objects representing received requests. Overrides Bonsai.Source<Bonsai.ZeroMQ.ResponseContext>.Generate() | Improve this Doc View Source Generate(IObservable<NetMQMessage>) Creates a response socket that returns all received requests and transmits an observable sequence of multiple part response messages. Declaration public IObservable<NetMQMessage> Generate(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source The sequence of NetMQ.NetMQMessage objects representing the multiple part response messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the response socket. | Improve this Doc View Source Generate(IObservable<Byte[]>) Creates a response socket that returns all received requests and transmits an observable sequence of binary-coded response messages. Declaration public IObservable<NetMQMessage> Generate(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source The sequence of binary-coded response messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the response socket. | Improve this Doc View Source Generate(IObservable<String>) Creates a response socket that returns all received requests and transmits an observable sequence of String response messages. Declaration public IObservable<NetMQMessage> Generate(IObservable<string> source) Parameters Type Name Description IObservable < String > source The sequence of String response messages to transmit. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the response socket. See Also SendResponse"
  },
  "api/Bonsai.ZeroMQ.ResponseContext.html": {
    "href": "api/Bonsai.ZeroMQ.ResponseContext.html",
    "title": "Class ResponseContext",
    "keywords": "Class ResponseContext Represents a request message received by a response socket. Inheritance Object ResponseContext Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class ResponseContext Properties | Improve this Doc View Source Request Gets the multiple part message representing the request message. Declaration public NetMQMessage Request { get; } Property Value Type Description NetMQ.NetMQMessage"
  },
  "api/Bonsai.ZeroMQ.Router.html": {
    "href": "api/Bonsai.ZeroMQ.Router.html",
    "title": "Class Router",
    "keywords": "Class Router Represents an operator that creates a router socket for tracking the identity of received requests so that responses can be matched even if computed concurrently. Inheritance Object Source < ResponseContext > Router Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Router : Source<ResponseContext> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Generate() Generates an observable sequence of requests received from a router socket, where the identity of each request is tracked so that responses can be matched even if computed concurrently. Declaration public override IObservable<ResponseContext> Generate() Returns Type Description IObservable < ResponseContext > An observable sequence of ResponseContext objects representing received requests. Overrides Bonsai.Source<Bonsai.ZeroMQ.ResponseContext>.Generate() | Improve this Doc View Source Generate(IObservable<NetMQMessage>) Creates a router socket that appends an identity to all received messages and reads it back from outgoing messages to determine the peer the message should be routed to. Declaration public IObservable<NetMQMessage> Generate(IObservable<NetMQMessage> source) Parameters Type Name Description IObservable < NetMQ.NetMQMessage > source The sequence of NetMQ.NetMQMessage objects representing the multiple part response messages to route back to peers. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing multiple part requests received from the router socket."
  },
  "api/Bonsai.ZeroMQ.SendResponse.html": {
    "href": "api/Bonsai.ZeroMQ.SendResponse.html",
    "title": "Class SendResponse",
    "keywords": "Class SendResponse Represents an operator that computes the result of a remote request asynchronously and transmits the response through the corresponding socket. Inheritance Object ExpressionBuilder WorkflowExpressionBuilder SendResponse Implements IWorkflowExpressionBuilder INamedElement IPropertyMappingBuilder IExpressionBuilder Inherited Members WorkflowExpressionBuilder.BuildWorkflow(IEnumerable<Expression>, Expression, Func<Expression, Expression>) WorkflowExpressionBuilder.Name WorkflowExpressionBuilder.Description WorkflowExpressionBuilder.INamedElement.Name WorkflowExpressionBuilder.Workflow WorkflowExpressionBuilder.WorkflowDescriptor Bonsai.Expressions.WorkflowExpressionBuilder.PropertyMappings ExpressionBuilder.ToString() ExpressionBuilder.Unwrap(ExpressionBuilder) ExpressionBuilder.GetWorkflowElement(ExpressionBuilder) ExpressionBuilder.GetVisualizerElement(ExpressionBuilder) ExpressionBuilder.GetVisualizerMappings(ExpressionBuilder) ExpressionBuilder.FromWorkflowElement(Object, ElementCategory) ExpressionBuilder.GetElementDisplayName(Type) ExpressionBuilder.GetElementDisplayName(Object) Bonsai.Expressions.ExpressionBuilder.SelectMembers(System.Linq.Expressions.Expression, System.String) Bonsai.Expressions.ExpressionBuilder.GetArgumentAccess(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression>, System.String) Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class SendResponse : WorkflowExpressionBuilder, IWorkflowExpressionBuilder, INamedElement, IPropertyMappingBuilder, IExpressionBuilder Constructors | Improve this Doc View Source SendResponse() Initializes a new instance of the SendResponse class. Declaration public SendResponse() | Improve this Doc View Source SendResponse(ExpressionBuilderGraph) Initializes a new instance of the SendResponse class with the specified expression builder workflow. Declaration public SendResponse(ExpressionBuilderGraph workflow) Parameters Type Name Description ExpressionBuilderGraph workflow The expression builder workflow instance that will be used by this builder to generate the output expression tree. Properties | Improve this Doc View Source ArgumentRange Declaration public override Range<int> ArgumentRange { get; } Property Value Type Description Range < Int32 > Overrides WorkflowExpressionBuilder.ArgumentRange Methods | Improve this Doc View Source Build(IEnumerable<Expression>) Declaration public override Expression Build(IEnumerable<Expression> arguments) Parameters Type Name Description IEnumerable < Expression > arguments Returns Type Description Expression Overrides ExpressionBuilder.Build(IEnumerable<Expression>) Implements IWorkflowExpressionBuilder INamedElement IPropertyMappingBuilder IExpressionBuilder"
  },
  "api/Bonsai.ZeroMQ.SocketInfo.html": {
    "href": "api/Bonsai.ZeroMQ.SocketInfo.html",
    "title": "Class SocketInfo",
    "keywords": "Class SocketInfo Represents information required for creating a NetMQ.NetMQSocket . Inheritance Object SocketInfo Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class SocketInfo"
  },
  "api/Bonsai.ZeroMQ.SocketType.html": {
    "href": "api/Bonsai.ZeroMQ.SocketType.html",
    "title": "Enum SocketType",
    "keywords": "Enum SocketType Specifies the basic types of message-queue sockets implementing the core patterns (pub-sub, req-rep, dealer-router, etc). Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public enum SocketType Fields Name Description Dealer Specifies a NetMQ.Sockets.DealerSocket . Pair Specifies a NetMQ.Sockets.PairSocket . Publisher Specifies a NetMQ.Sockets.PublisherSocket . Pull Specifies a NetMQ.Sockets.PullSocket . Push Specifies a NetMQ.Sockets.PushSocket . Request Specifies a NetMQ.Sockets.RequestSocket . Response Specifies a NetMQ.Sockets.ResponseSocket . Router Specifies a NetMQ.Sockets.RouterSocket . Stream Specifies a NetMQ.Sockets.StreamSocket . Subscriber Specifies a NetMQ.Sockets.SubscriberSocket . XPublisher Specifies a NetMQ.Sockets.XPublisherSocket . XSubscriber Specifies a NetMQ.Sockets.XSubscriberSocket ."
  },
  "api/Bonsai.ZeroMQ.Subscriber.html": {
    "href": "api/Bonsai.ZeroMQ.Subscriber.html",
    "title": "Class Subscriber",
    "keywords": "Class Subscriber Represents an operator that creates a subscriber socket for receiving a sequence of messages as part of the pub-sub pattern. Inheritance Object Source < NetMQ.NetMQMessage > Subscriber Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class Subscriber : Source<NetMQMessage> Properties | Improve this Doc View Source ConnectionString Gets or sets a value specifying the endpoints to attach the socket to. Declaration [TypeConverter(typeof(ConnectionStringConverter))] public string ConnectionString { get; set; } Property Value Type Description String | Improve this Doc View Source Topic Gets or sets the topic that the socket will subscribe to. Declaration public string Topic { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Generate() Creates a subscriber socket for receiving an observable sequence of multiple part messages on the specified Topic . Declaration public override IObservable<NetMQMessage> Generate() Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence of NetMQ.NetMQMessage objects representing all multiple part messages received from the subscriber socket. Overrides Bonsai.Source<NetMQ.NetMQMessage>.Generate() See Also Publisher"
  },
  "api/Bonsai.ZeroMQ.ToMessage.html": {
    "href": "api/Bonsai.ZeroMQ.ToMessage.html",
    "title": "Class ToMessage",
    "keywords": "Class ToMessage Represents an operator that creates a multiple part message from an observable sequence. Inheritance Object Combinator < NetMQ.NetMQFrame , NetMQ.NetMQMessage > ToMessage Inherited Members Combinator<NetMQFrame, NetMQMessage>.Process(IObservable<NetMQFrame>) Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Bonsai.ZeroMQ Assembly : Bonsai.ZeroMQ.dll Syntax public class ToMessage : Combinator<NetMQFrame, NetMQMessage> Methods | Improve this Doc View Source Process(IObservable<NetMQFrame>) Creates a multiple part message from an observable sequence of individual message frames. Declaration public override IObservable<NetMQMessage> Process(IObservable<NetMQFrame> source) Parameters Type Name Description IObservable < NetMQ.NetMQFrame > source A sequence of NetMQ.NetMQFrame objects representing the individual message parts. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence containing a single NetMQ.NetMQMessage object representing the created multiple part message. Overrides Bonsai.Combinator<NetMQ.NetMQFrame, NetMQ.NetMQMessage>.Process(System.IObservable<NetMQ.NetMQFrame>) | Improve this Doc View Source Process(IObservable<Byte[]>) Creates a multiple part message from an observable sequence of individual data buffers. Declaration public IObservable<NetMQMessage> Process(IObservable<byte[]> source) Parameters Type Name Description IObservable < Byte []> source A sequence of byte-array objects representing the individual message parts. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence containing a single NetMQ.NetMQMessage object representing the created multiple part message. | Improve this Doc View Source Process(IObservable<String>) Creates a multiple part message from an observable sequence of individual message parts. Declaration public IObservable<NetMQMessage> Process(IObservable<string> source) Parameters Type Name Description IObservable < String > source A sequence of String objects representing the individual message parts. Returns Type Description IObservable < NetMQ.NetMQMessage > An observable sequence containing a single NetMQ.NetMQMessage object representing the created multiple part message."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction",
    "keywords": "Introduction Bonsai.ZeroMQ is a Bonsai interface for ZeroMQ providing a flexible networking and messaging library for coordinating distributed processing. The core patterns discussed in the ØMQ Guide are exposed via reactive operators and discussed in detail in the Patterns chapter. You can use Bonsai.ZeroMQ to transmit requests and data across different workflows running in the same computer, or in a different computer. You can also use the package to create endpoints for interfacing Bonsai with other languages supporting ZeroMQ. Installing the package To install Bonsai.ZeroMQ use the Bonsai package manager and search for the Bonsai - ZeroMQ package."
  },
  "articles/overview.html": {
    "href": "articles/overview.html",
    "title": "Installing the package",
    "keywords": "Bonsai.ZeroMQ is a Bonsai interface for ZeroMQ providing a flexible networking and messaging library for coordinating distributed processing. The core patterns discussed in the ØMQ Guide are exposed via reactive operators and discussed in detail in the Patterns chapter. You can use Bonsai.ZeroMQ to transmit requests and data across different workflows running in the same computer, or in a different computer. You can also use the package to create endpoints for interfacing Bonsai with other languages supporting ZeroMQ. Installing the package To install Bonsai.ZeroMQ use the Bonsai package manager and search for the Bonsai - ZeroMQ package."
  },
  "articles/patterns.html": {
    "href": "articles/patterns.html",
    "title": "Patterns",
    "keywords": "Patterns ZeroMQ provides a set of sockets and patterns for building distributed systems. We have adapted these patterns to fit neatly into the Bonsai visual language by defining a set of reactive operators named after each socket type. Pattern Description Operators Publish-Subscribe One to many data distribution Publisher , Subscriber Request-Response Remote procedure call Request , Response Router-Dealer Asynchronous requests from multiple clients Router , Dealer Push-Pull Fan-out / fan-in task distribution Push , Pull Proxy Broker / intermediation patterns ProxyFrontend , ProxyBackend Each section in this chapter describes a basic ZeroMQ messaging pattern, usually involving complementary pairs of sockets, and provides examples of use that you can copy and paste directly into the editor."
  },
  "articles/proxy.html": {
    "href": "articles/proxy.html",
    "title": "Proxy",
    "keywords": "Proxy (Intermediation) The basic messaging patterns in ZeroMQ use direct connections between socket endpoints. The role of proxies, or intermediaries , is to abstract away direct references between endpoints, replacing them by references to the proxy. The proxy itself is specified by exposing a ProxyFrontend socket and a ProxyBackend socket. All primary messages are routed from front-end to back-end, but secondary responses or subscription messages can also flow from back-end to front-end as required by the specified socket types. This enables easily building variants of the basic patterns where peers are discovered dynamically or pools of clients and services can join and leave at any time, with the only constraint that all message passing is stateless. The examples below illustrate some of the most common proxy patterns. Example: Extended Publish-Subscribe In the basic Publish-Subscribe pattern, a set of subscribers connect to a single publisher. Typically the publisher binds to its endpoint and does not know the identity of the subscribers. However, all subscribers have to know the identity of the publisher endpoint. This makes it hard to replace the publisher, or to allow for multiple publishers to push data to subscribers. The extended publish-subscribe pattern allows for dynamic discovery of both publishers and subscribers by introducing a proxy. This way, publishers do not need to know the identity of subscribers, and subscribers do not need to know the identity of publishers. Only the identity of the proxy endpoints is required. graph LR A(Publisher) ---|PUB| D(<p></p>) B(Publisher) ---|PUB| D(<p></p>) C(Publisher) ---|PUB| D(<p></p>) D ---|XSUB| E(Proxy) E ---|XPUB| F(<p></p>) F -->|SUB| G(Subscriber) F -->|SUB| H(Subscriber) F -->|SUB| I(Subscriber) The proxy needs to be configured with a XSubscriber as the front-end socket, and a XPublisher as the back-end socket. In the example below, two timers publish periodic updates to an unknown set of subscribers using this proxy pattern. Example: Extended Request-Response In the basic Request-Response pattern, one client connects to a single server. We can also use Router-Dealer patterns so that multiple asynchronous requests can be handled in parallel by the server. However, in both cases we assume there is a single endpoint for handling service requests which is known by all clients. The extended request-response pattern allows for clusters of workers to dynamically join or leave a shared message queue, and handle requests from existing clients as they arrive. The client connects to the proxy front-end, and workers to the proxy back-end. This way we can scale up the number of workers without having to change anything about the clients. graph LR A(Client) ---|REQ| D(<p></p>) B(Client) ---|REQ| D(<p></p>) C(Client) ---|REQ| D(<p></p>) D ---|Router| E(Proxy) E ---|Dealer| F(<p></p>) F -->|REP| G(Worker) F -->|REP| H(Worker) F -->|REP| I(Worker) The shared queue is simply a proxy configured with a Router as the front-end socket, and a Dealer as the back-end socket. In the example below, a timer sends periodic requests to the shared queue, and workers alternate servicing the requests. Each reply is tagged with the identity of the worker who handled the request for easy visualization."
  },
  "articles/pub-sub.html": {
    "href": "articles/pub-sub.html",
    "title": "Publish-Subscribe",
    "keywords": "Publish-Subscribe The publish-subscribe (pub-sub) pattern implements one-way data distribution, in which a Publisher node pushes a stream of updates to a set of Subscriber nodes. Messages pushed by the publisher are sent to all subscribers active at the moment of sending the message. graph LR A(Publisher) ---|PUB| B(<p></p>) B -->|SUB| D(Subscriber) B -->|SUB| E(Subscriber) B -->|SUB| F(Subscriber) Distribution is fully asynchronous, and publisher and subscriber nodes can be started in any order. Publisher nodes may specify a Topic for each sent message. When connecting to a publisher, subscriber nodes can subscribe to one or more topics. If no topic is specified, subscriber nodes will receive all messages from the publisher. Warning Subscriber nodes are not guaranteed to receive the same number of messages sent by the publisher or by other subscribers. Initializing a connection to the publisher can take long enough that messages already being sent are lost, so it is best to assume that pub-sub streams are infinite streams with no beginning or end. Example: Simple publish-subscribe stream In the example below, a periodic timer publishes counter updates with multiple downstream subscribers. The numeric data is formatted as a string message for transmission, and parsed back on reception."
  },
  "articles/push-pull.html": {
    "href": "articles/push-pull.html",
    "title": "Push-Pull",
    "keywords": "Push-Pull (Pipeline) The pipeline (push-pull) pattern is intended for task distribution in a fan-out (one-to-many) or fan-in (many-to-one) pattern. The Push operator is used to distribute messages to a set of anonymous peers using a round-robin algorithm. Peers use a Pull source to receive tasks using a fair-queue algorithm. The most common application of the pipeline pattern is to implement divide-and-conquer strategies, where a node ( Ventilator ) divides a large computation into smaller sub-tasks which are distributed to a pool of Workers . All results are then pushed to be aggregated by a collector ( Sink ). graph LR A(Ventilator) ---|PUSH| B(<p></p>) B -->|PULL| D(Worker) B -->|PULL| E(Worker) B -->|PULL| F(Worker) D ---|PUSH| G(<p></p>) E ---|PUSH| G F ---|PUSH| G G -->|PULL| H(Sink) Messages are not discarded even if no worker nodes are available to process tasks, and new nodes can join the pattern at any time. Warning Messages may be lost if a worker node crashes in the middle of processing its chunk, or during transmission of a task. Feedback strategies at the level of the collector may be used to mitigate for such failures if necessary. Example: Fan-out task distribution In the example below, a periodic timer distributes unique identifiers to anonymous worker peers. Notice that each identifier is pulled by one and only one worker, using a round-robin strategy."
  },
  "articles/recipes.html": {
    "href": "articles/recipes.html",
    "title": "Recipes",
    "keywords": "Recipes This section contains a collection of recipes for working with ZeroMQ in Bonsai. It goes beyond the basic patterns discussed earlier in the manual, and touches on problems of interfacing ZeroMQ with other packages, which might come up when you actually try to use the library for specific applications. Video streams The Vision package provides the EncodeImage and DecodeImage operators to compress raw image frames into byte streams using a variety of common compression algorithms. The example below shows how to create a simple video streaming server using the Publish-Subscribe pattern. Binary data ZeroMQ can be used as a transport protocol for other binary-coded data representations. The example below shows how to use the Format and Parse operators in the OSC package to transmit complex types over byte streams, while using ZeroMQ to allow more flexible networking patterns."
  },
  "articles/req-rep.html": {
    "href": "articles/req-rep.html",
    "title": "Request-Response",
    "keywords": "Request-Response The request-response (req-rep) pattern is used to connect a set of clients to a set of services. It can also be seen as a form of remote procedure call and a simple task distribution pattern. graph LR C(Client) C -->|REQ| D(Server) D -->|REP| C On the client side, messages containing the details of each procedure call are pushed by each client using a Request node. On the server side, a Response node is used to receive notifications of new requests. Responses can be evaluated using the SendResponse operator. Warning This pattern is strictly sequential: if multiple requests are sent to a Response socket, they will be handled by the server one at a time, in order of arrival. For asynchronous processing of requests, see the Router-Dealer pattern. Example: Simple request-response In the example below, a periodic timer sends counter updates as a request to the server. The server replies by formatting the input string with the prefix reply ."
  },
  "articles/router-dealer.html": {
    "href": "articles/router-dealer.html",
    "title": "Router-Dealer",
    "keywords": "Router-Dealer In the Request-Response pattern we typically have one client sending requests to a single server. However, in practice we often need to allow multiple requests to be processed in parallel by the server. We can use a Router socket to achieve this. graph LR A(Client) -- REQ --> D B(Client) -- REQ --> D C(Client) -- REQ --> D D(Router) -- id:REQ --> E E(Worker) -- id:REP --> D On the client side, requests are sent using a Request node as normal, but now with multiple clients sending requests. On the server side, a Router node is used to dispatch notifications of new requests to workers. Responses can be evaluated asynchronously using the SendResponse operator. Warning Requests dispatched by the router are prefixed with one or more identity frames that uniquely specify the client to which the response must be sent. Responses must preserve these frames to ensure that messages can be routed back to the client. Example: Asynchronous request-response In the example below, multiple clients send periodic requests to an asynchronous server. The server replies by formatting the input string with the prefix reply . Content frames are stored after the empty delimiter frame. For simple requests this is usually the last frame, which can be retrieved directly using the Last property. The SendResponse operator automatically takes care of pushing all identity frames from the request into the response to generate an outgoing message ready to be routed."
  },
  "index.html": {
    "href": "index.html",
    "title": "Bonsai - ZeroMQ Documentation",
    "keywords": "Bonsai - ZeroMQ Documentation Bonsai.ZeroMQ is a Bonsai interface for ZeroMQ providing a flexible networking and messaging library for coordinating distributed processing. The core patterns discussed in the ØMQ Guide are exposed via reactive operators and discussed in detail in the Patterns chapter. You can use Bonsai.ZeroMQ to transmit requests and data across different workflows running in the same computer, or in a different computer. You can also use the package to create endpoints for interfacing Bonsai with other languages supporting ZeroMQ. Installing the package To install Bonsai.ZeroMQ use the Bonsai package manager and search for the Bonsai - ZeroMQ package. Warning These docs are under active development, feel free to contribute by either raising an issue or following the links to Improve this Doc ."
  }
}